// +build !ignore_autogenerated

/*
Copyright 2018 BlackRock, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by main. DO NOT EDIT.

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1alpha1

import (
	"github.com/go-openapi/spec"
	"k8s.io/kube-openapi/pkg/common"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPEventSource":        schema_pkg_apis_eventsource_v1alpha1_AMQPEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CalendarEventSource":    schema_pkg_apis_eventsource_v1alpha1_CalendarEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSource":            schema_pkg_apis_eventsource_v1alpha1_EventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceSpec":        schema_pkg_apis_eventsource_v1alpha1_EventSourceSpec(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.FileEventSource":        schema_pkg_apis_eventsource_v1alpha1_FileEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Filter":                 schema_pkg_apis_eventsource_v1alpha1_Filter(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubEventSource":      schema_pkg_apis_eventsource_v1alpha1_GithubEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GitlabEventSource":      schema_pkg_apis_eventsource_v1alpha1_GitlabEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.HDFSClientConfig":       schema_pkg_apis_eventsource_v1alpha1_HDFSClientConfig(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.HDFSEventSource":        schema_pkg_apis_eventsource_v1alpha1_HDFSEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaEventSource":       schema_pkg_apis_eventsource_v1alpha1_KafkaEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.MQTTEventSource":        schema_pkg_apis_eventsource_v1alpha1_MQTTEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSEventSource":        schema_pkg_apis_eventsource_v1alpha1_NATSEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PubSubEventSource":      schema_pkg_apis_eventsource_v1alpha1_PubSubEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceEventSource":    schema_pkg_apis_eventsource_v1alpha1_ResourceEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceFilter":         schema_pkg_apis_eventsource_v1alpha1_ResourceFilter(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Artifact":             schema_pkg_apis_eventsource_v1alpha1_S3Artifact(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Bucket":               schema_pkg_apis_eventsource_v1alpha1_S3Bucket(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Filter":               schema_pkg_apis_eventsource_v1alpha1_S3Filter(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SNSEventSource":         schema_pkg_apis_eventsource_v1alpha1_SNSEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SQSEventSource":         schema_pkg_apis_eventsource_v1alpha1_SQSEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SlackEventSource":       schema_pkg_apis_eventsource_v1alpha1_SlackEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Source":                 schema_pkg_apis_eventsource_v1alpha1_Source(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridEventSource": schema_pkg_apis_eventsource_v1alpha1_StorageGridEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WatchPathConfig":        schema_pkg_apis_eventsource_v1alpha1_WatchPathConfig(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource":     schema_pkg_apis_eventsource_v1alpha1_WebhookEventSource(ref),
	}
}

func schema_pkg_apis_eventsource_v1alpha1_AMQPEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AMQPEventSource contains configuration required to connect to rabbitmq service and process messages",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL for rabbitmq service",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"exchangeName": {
						SchemaProps: spec.SchemaProps{
							Description: "ExchangeName is the exchange name For more information, visit https://www.rabbitmq.com/tutorials/amqp-concepts.html",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"exchangeType": {
						SchemaProps: spec.SchemaProps{
							Description: "ExchangeType is rabbitmq exchange type",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"routingKey": {
						SchemaProps: spec.SchemaProps{
							Description: "Routing key for bindings",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"backoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/wait.Backoff"),
						},
					},
				},
				Required: []string{"url", "exchangeName", "exchangeType", "routingKey"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/wait.Backoff"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_CalendarEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CalendarEventSource describes a time based dependency. One of the fields (schedule, interval, or recurrence) must be passed. Schedule takes precedence over interval; interval takes precedence over recurrence",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"schedule": {
						SchemaProps: spec.SchemaProps{
							Description: "Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"interval": {
						SchemaProps: spec.SchemaProps{
							Description: "Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h...",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"recurrence": {
						SchemaProps: spec.SchemaProps{
							Description: "List of RRULE, RDATE and EXDATE lines for a recurring event, as specified in RFC5545. RRULE is a recurrence rule which defines a repeating pattern for recurring events. RDATE defines the list of DATE-TIME values for recurring events. EXDATE defines the list of DATE-TIME exceptions for recurring events. the combination of these rules and dates combine to form a set of date times. NOTE: functionality currently only supports EXDATEs, but in the future could be expanded.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"timezone": {
						SchemaProps: spec.SchemaProps{
							Description: "Timezone in which to run the schedule",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"userPayload": {
						SchemaProps: spec.SchemaProps{
							Description: "UserPayload will be sent to sensor as extra data once the event is triggered",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"schedule", "interval"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EventSource is the definition of an event source",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Status"),
						},
					},
				},
				Required: []string{"metadata", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/apimachinery/pkg/apis/meta/v1.Status"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventSourceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EventSourceSpec represents event source specifications",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"source": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Source"),
						},
					},
				},
				Required: []string{"source"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Source"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_FileEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FileEventSource is the event source for file gateway",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"directory": {
						SchemaProps: spec.SchemaProps{
							Description: "Directory to watch for events",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pathRegexp": {
						SchemaProps: spec.SchemaProps{
							Description: "PathRegexp is regexp of relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of file operations to watch Refer https://github.com/fsnotify/fsnotify/blob/master/fsnotify.go for more information",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"directory", "type"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_Filter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Filter represents filters to apply to bucket notifications for specifying constraints on objects",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"prefix": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"suffix": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"prefix", "suffix"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_GithubEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GithubEventSource contains information to setup a github project integration",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"id": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook ID",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"hook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook",
							Ref:         ref("github.com/argoproj/argo-events/gateways/common.Webhook"),
						},
					},
					"owner": {
						SchemaProps: spec.SchemaProps{
							Description: "GitHub owner name i.e. argoproj",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repository": {
						SchemaProps: spec.SchemaProps{
							Description: "GitHub repo name i.e. argo-events",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Description: "Github events to subscribe to which the gateway will subscribe",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"apiToken": {
						SchemaProps: spec.SchemaProps{
							Description: "K8s secret containing github api token",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"webHookSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "K8s secret containing WebHook Secret",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"insecure": {
						SchemaProps: spec.SchemaProps{
							Description: "Insecure tls verification",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"active": {
						SchemaProps: spec.SchemaProps{
							Description: "Active",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"contentType": {
						SchemaProps: spec.SchemaProps{
							Description: "ContentType json or form",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"githubBaseURL": {
						SchemaProps: spec.SchemaProps{
							Description: "GitHub base URL (for GitHub Enterprise)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"githubUploadURL": {
						SchemaProps: spec.SchemaProps{
							Description: "GitHub upload URL (for GitHub Enterprise)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"id", "hook", "owner", "repository", "events", "apiToken", "webHookSecret", "insecure", "active", "contentType", "githubBaseURL", "githubUploadURL"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/gateways/common.Webhook", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_GitlabEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GitlabEventSource contains information to setup a gitlab project integration",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"id": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook Id",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"hook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook",
							Ref:         ref("github.com/argoproj/argo-events/gateways/common.Webhook"),
						},
					},
					"projectId": {
						SchemaProps: spec.SchemaProps{
							Description: "ProjectId is the id of project for which integration needs to setup",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"event": {
						SchemaProps: spec.SchemaProps{
							Description: "Event is a gitlab event to listen to. Refer https://github.com/xanzy/go-gitlab/blob/bf34eca5d13a9f4c3f501d8a97b8ac226d55e4d9/projects.go#L794.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"accessToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AccessToken is reference to k8 secret which holds the gitlab api access information",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"enableSSLVerification": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableSSLVerification to enable ssl verification",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"gitlabBaseURL": {
						SchemaProps: spec.SchemaProps{
							Description: "GitlabBaseURL is the base URL for API requests to a custom endpoint",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"id", "hook", "projectId", "event", "accessToken", "enableSSLVerification", "gitlabBaseURL"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/gateways/common.Webhook", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_HDFSClientConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HDFSClientConfig contains HDFS client configurations",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"addresses": {
						SchemaProps: spec.SchemaProps{
							Description: "Addresses is accessible addresses of HDFS name nodes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"hdfsUser": {
						SchemaProps: spec.SchemaProps{
							Description: "HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbCCacheSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbCCacheSecret is the secret selector for Kerberos ccache Either ccache or keytab can be set to use Kerberos.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"krbKeytabSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbKeytabSecret is the secret selector for Kerberos keytab Either ccache or keytab can be set to use Kerberos.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"krbUsername": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbRealm": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbConfigConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbConfig is the configmap selector for Kerberos config as string It must be set if either ccache or keytab is used.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"krbServicePrincipalName": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"addresses"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ConfigMapKeySelector", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_HDFSEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HDFSEventSource contains information to setup a HDFS integration",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"directory": {
						SchemaProps: spec.SchemaProps{
							Description: "Directory to watch for events",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pathRegexp": {
						SchemaProps: spec.SchemaProps{
							Description: "PathRegexp is regexp of relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of file operations to watch",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"checkInterval": {
						SchemaProps: spec.SchemaProps{
							Description: "CheckInterval is a string that describes an interval duration to check the directory state, e.g. 1s, 30m, 2h... (defaults to 1m)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"addresses": {
						SchemaProps: spec.SchemaProps{
							Description: "Addresses is accessible addresses of HDFS name nodes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"hdfsUser": {
						SchemaProps: spec.SchemaProps{
							Description: "HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbCCacheSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbCCacheSecret is the secret selector for Kerberos ccache Either ccache or keytab can be set to use Kerberos.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"krbKeytabSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbKeytabSecret is the secret selector for Kerberos keytab Either ccache or keytab can be set to use Kerberos.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"krbUsername": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbRealm": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbConfigConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbConfig is the configmap selector for Kerberos config as string It must be set if either ccache or keytab is used.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"krbServicePrincipalName": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"directory", "type", "addresses"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ConfigMapKeySelector", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_KafkaEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KafkaEventSource defines configuration required to connect to kafka cluster",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL to kafka cluster",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "Partition name",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topic": {
						SchemaProps: spec.SchemaProps{
							Description: "Topic name",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"backoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/wait.Backoff"),
						},
					},
				},
				Required: []string{"url", "partition", "topic"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/wait.Backoff"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_MQTTEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MQTTEventSource contains information to connect to MQTT broker",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL to connect to broker",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topic": {
						SchemaProps: spec.SchemaProps{
							Description: "Topic name",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"clientId": {
						SchemaProps: spec.SchemaProps{
							Description: "Client ID",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"backoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/wait.Backoff"),
						},
					},
				},
				Required: []string{"url", "topic", "clientId"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/wait.Backoff"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_NATSEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NATSEventSource contains configuration to connect to NATS cluster",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL to connect to natsConfig cluster",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subject": {
						SchemaProps: spec.SchemaProps{
							Description: "Subject name",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"backoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/wait.Backoff"),
						},
					},
				},
				Required: []string{"url", "subject"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/wait.Backoff"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_PubSubEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PubSubEventSource contains configuration to subscribe to GCP PubSub topic",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"projectID": {
						SchemaProps: spec.SchemaProps{
							Description: "ProjectID is the unique identifier for your project on GCP",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topic": {
						SchemaProps: spec.SchemaProps{
							Description: "Topic on which a subscription will be created",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"credentialsFile": {
						SchemaProps: spec.SchemaProps{
							Description: "CredentialsFile is the file that contains credentials to authenticate for GCP",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"projectID", "topic", "credentialsFile"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_ResourceEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EventSource refers to a dependency on a k8s resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace where resource is deployed",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter is applied on the metadata of the resource",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceFilter"),
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version of the source",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"group": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type is the event type. Refer https://github.com/kubernetes/apimachinery/blob/dcb391cde5ca0298013d43336817d20b74650702/pkg/watch/watch.go#L43 If not provided, the gateway will watch all events for a resource.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"namespace", "version", "group", "version", "kind"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceFilter"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_ResourceFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceFilter contains K8 ObjectMeta information to further filter resource event objects",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"prefix": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"createdBy": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_S3Artifact(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "S3ArtifactEventSource contains information about an artifact in S3",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"bucket": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Bucket"),
						},
					},
					"region": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"insecure": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"boolean"},
							Format: "",
						},
					},
					"accessKey": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"secretKey": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Filter"),
						},
					},
				},
				Required: []string{"endpoint", "bucket", "accessKey", "secretKey"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Bucket", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Filter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_S3Bucket(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "S3Bucket contains information to describe an S3 Bucket",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"key": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"name"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_S3Filter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "S3Filter represents filters to apply to bucket nofifications for specifying constraints on objects",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"prefix": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"suffix": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"prefix", "suffix"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_SNSEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SNSEventSource contains configuration to subscribe to SNS topic",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hook": {
						SchemaProps: spec.SchemaProps{
							Description: "Hook defines a webhook.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource"),
						},
					},
					"topicArn": {
						SchemaProps: spec.SchemaProps{
							Description: "TopicArn to connect to",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"accessKey": {
						SchemaProps: spec.SchemaProps{
							Description: "AccessKey refers K8 secret containing aws access key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"secretKey": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretKey refers K8 secret containing aws secret key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"region": {
						SchemaProps: spec.SchemaProps{
							Description: "Region to operate in",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"hook", "topicArn", "accessKey", "secretKey", "region"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_SQSEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SQSEventSource contains information to listen to AWS SQS",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"accessKey": {
						SchemaProps: spec.SchemaProps{
							Description: "AccessKey refers K8 secret containing aws access key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"secretKey": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretKey refers K8 secret containing aws secret key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"region": {
						SchemaProps: spec.SchemaProps{
							Description: "Region to operate in",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"queue": {
						SchemaProps: spec.SchemaProps{
							Description: "Queue is AWS SQS queue to listen to for messages",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"waitTimeSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "WaitTimeSeconds is The duration (in seconds) for which the call waits for a message to arrive in the queue before returning.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"accessKey", "secretKey", "region", "queue", "waitTimeSeconds"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_SlackEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SlackEventSource contains configuration for slack",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"token": {
						SchemaProps: spec.SchemaProps{
							Description: "Token for URL verification handshake",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"hook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook",
							Ref:         ref("github.com/argoproj/argo-events/gateways/common.Webhook"),
						},
					},
				},
				Required: []string{"token", "hook"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/gateways/common.Webhook", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_Source(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource"),
									},
								},
							},
						},
					},
					"artifact": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Artifact"),
									},
								},
							},
						},
					},
					"calendar": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CalendarEventSource"),
									},
								},
							},
						},
					},
					"file": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.FileEventSource"),
									},
								},
							},
						},
					},
					"resource": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceEventSource"),
									},
								},
							},
						},
					},
					"amqp": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPEventSource"),
									},
								},
							},
						},
					},
					"kakfa": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaEventSource"),
									},
								},
							},
						},
					},
					"mqtt": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.MQTTEventSource"),
									},
								},
							},
						},
					},
					"nats": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSEventSource"),
									},
								},
							},
						},
					},
					"sns": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SNSEventSource"),
									},
								},
							},
						},
					},
					"sqs": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SQSEventSource"),
									},
								},
							},
						},
					},
					"pubSub": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PubSubEventSource"),
									},
								},
							},
						},
					},
					"github": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubEventSource"),
									},
								},
							},
						},
					},
					"gitlab": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GitlabEventSource"),
									},
								},
							},
						},
					},
					"hdfs": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.HDFSEventSource"),
									},
								},
							},
						},
					},
					"slack": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SlackEventSource"),
									},
								},
							},
						},
					},
					"storageGrid": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridEventSource"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CalendarEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.FileEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GitlabEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.HDFSEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.MQTTEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PubSubEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.S3Artifact", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SNSEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SQSEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SlackEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_StorageGridEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StorageGridEventSource contains configuration for storage grid sns",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource"),
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Description: "Events are s3 bucket notification events. For more information on s3 notifications, follow https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations Note that storage grid notifications do not contain `s3:`",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter on object key which caused the notification.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Filter"),
						},
					},
				},
				Required: []string{"hook"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Filter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_WatchPathConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"directory": {
						SchemaProps: spec.SchemaProps{
							Description: "Directory to watch for events",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pathRegexp": {
						SchemaProps: spec.SchemaProps{
							Description: "PathRegexp is regexp of relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"directory"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_WebhookEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WebhookEventSource contains general purpose REST API configuration",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "REST API endpoint",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"method": {
						SchemaProps: spec.SchemaProps{
							Description: "Method is HTTP request method that indicates the desired action to be performed for a given resource. See RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port on which HTTP server is listening for incoming events.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL is the url of the server.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serverCertPath": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerCertPath refers the file that contains the cert.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serverKeyPath": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerKeyPath refers the file that contains private key",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"endpoint", "method", "port", "url"},
			},
		},
	}
}
